package org.daisleyharrison.security.utilities.typegenerators;

import org.daisleyharrison.security.utilities.TypeGenerator;
import org.daisleyharrison.security.utilities.stringtemplate.CompiledTemplate;
import org.daisleyharrison.security.utilities.stringtemplate.Generator;
import org.daisleyharrison.security.utilities.stringtemplate.MacroProvider;
import org.daisleyharrison.security.utilities.stringtemplate.Modifier;
import org.daisleyharrison.security.utilities.stringtemplate.ModifierProvider;
import org.daisleyharrison.security.utilities.stringtemplate.SetProvider;
import org.daisleyharrison.security.utilities.stringtemplate.StringTemplateCompiler;
import org.daisleyharrison.security.utilities.stringtemplate.internal.GeneratorProvider;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.stream.Stream;

import java.util.HashMap;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

/**
 * Generates random strings based on the supplied format template
 * 
 * The format template syntax is as follows:
 * 
 * where:
 * 
 * specifier +
 * 
 * specifier syntax is:
 * 
 * { "<" set ">" | "[" words "]" | text } [ "|"" separator [ "|"" format ] "|""]
 * [ "{" { max | min "," max } "}"]
 * 
 * where:
 * 
 * set is a set name of the form: { "a" - "z" | "A" - "Z" | "_" | "-"} +
 * 
 * built-in set names are as follows:
 * 
 * alpha-lower - lower case alphabet a-z alpha-upper - upper case alphabet A-Z
 * 
 * digit - digits 0-9 separator - all ascii non-whitespace sepparators
 * 
 * alpha-mixed - a-z and A-Z alpha-numeric-mixed - a-z, A-Z and 0-9
 * 
 * printable - any printable ascii character integer - The set of all integers
 * 
 * double - The set of all double floating point numbers
 * 
 * float - The set of all floating point numbers
 * 
 * boolean - The set [true false]
 * 
 * date - The set of all dates and times from the Jan 01 1970 to the Dec 31 9999
 * 
 * uuid - The set of universally unique identifies (generated by
 * UURI.randomUUID())
 * 
 * time-zone-id - The set of all java time zone ids
 * 
 * country-abbreviation - The set of ISO country abbreviations
 * 
 * country - The set of country names
 * 
 * first-name - Popular engish first names
 * 
 * last-name - Popular english last names
 * 
 * lorem-paragraph - Lorem Ipsum paragraphs
 * 
 * lorem-word - Lorem Ipsum words
 * 
 * us-city - us city names
 * 
 * us-state-abrveiations - us state abbreviations
 * 
 * us-state - us state names
 * 
 * weekday-abbreviation - Mon-Sun
 * 
 * weekday - Monday = Sunday
 * 
 * further sets can be added by including a json resource file containing an
 * array of strings. The resource path is
 * org/daisleyharrison/security/utilities/typegenerators/sets/<setname>.json
 *
 * words are a whitespace sepparated list of character sequences "\[" is
 * equivalent to "[" for example:
 * 
 * [red green blue white black brown yellow orange]|, |{5}
 * 
 * The above would generate a comma separaterd list of 0 to 5 colors.
 * 
 * text is any boilerplate text between specifiers (can also include "\|" "\["
 * "\]" "\{" "\}")
 * 
 * format is a standard java format template that will be applied the the
 * generated random item. for example:
 * 
 * <date>|, |%tm/%<td/%<tY %<tH:%<tm:%<tS|{1, 10}
 * 
 * The above would generate between 1 and 10 dates sepparated by ", " (note for
 * date formats only <$, the format index is required) if format is not specifed
 * the item will be generated as if toString() was called.
 * 
 * max is a whole number indicating the maximum number of items to generate
 * 
 * min is a whole number indicating the minimum number of items to generate
 * 
 * if max and min are not specified only 1 item will be generated
 */
public class RandomStringFormatGenerator
        implements TypeGenerator<String>, SetProvider, MacroProvider, GeneratorProvider, ModifierProvider {
    private static final ObjectMapper mapper = new ObjectMapper();
    private static final String[] ALPHA_LOWER = { "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n",
            "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z" };
    private static final String[] ALPHA_UPPER = { "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N",
            "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z" };
    private static final String[] DIGIT = { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" };
    private static final String[] SEPARATORS = { "`", "~", "!", "@", "#", "$", "%", "^", "&", "*", "(", ")", "_", "-",
            "+", "=", "{", "[", "}", "]", "|", "\\", ":", ";", "\"", "'", "<", ",", ">", ".", "?", "/" };
    private static final String NOOP_MODIFIER_NAME = "noop";
    private static final Map<Character, Character> DIGIFY_MAP = Map.of('e', '3', 'g', '9', 'i', '1', 'l', '1', 'o', '0',
            's', '5', 'z', '2');
    private String pattern;
    private String format;
    private static Map<String, String[]> sets = new HashMap<>();
    private static Map<String, TypeGenerator<?>> typeGenerators = new HashMap<>();
    private static Map<String, String> macros = new HashMap<>();

    private static Map<String, Modifier> modifiers = new HashMap<>();

    /**
     * Build-in sets
     */
    static {
        sets.put("boolean", new String[]{"true", "false"});
        sets.put("alpha", ALPHA_LOWER);
        sets.put("alpha-lower", ALPHA_LOWER);
        sets.put("alpha-upper", ALPHA_UPPER);
        sets.put("digit", DIGIT);
        sets.put("separator", SEPARATORS);
        sets.put("alpha-mixed",
                Stream.concat(Arrays.stream(ALPHA_LOWER), Arrays.stream(ALPHA_UPPER)).toArray(String[]::new));
        sets.put("alpha-numeric",
                Stream.concat(Arrays.stream(ALPHA_LOWER), Arrays.stream(DIGIT)).toArray(String[]::new));
        sets.put("alpha-numeric-mixed", Stream
                .concat(Stream.concat(Arrays.stream(ALPHA_LOWER), Arrays.stream(ALPHA_UPPER)), Arrays.stream(DIGIT))
                .toArray(String[]::new));
        sets.put("printable",
                Stream.concat(Stream.concat(Stream.concat(Arrays.stream(ALPHA_LOWER), Arrays.stream(ALPHA_UPPER)),
                        Arrays.stream(DIGIT)), Arrays.stream(SEPARATORS)).toArray(String[]::new));

        typeGenerators.put("integer", new RandomIntegerGenerator(""));
        typeGenerators.put("double", new RandomDoubleGenerator(""));
        typeGenerators.put("float", new RandomFloatGenerator(""));
        typeGenerators.put("date", new RandomDateGenerator(""));
        typeGenerators.put("uuid", new RandomIntegerGenerator(""));
        typeGenerators.put("time-zone-id", new RandomStringTimeZoneIdGenerator(""));

        modifiers.put("title", t -> {
            return toTitleCase(t, false);
        });

        modifiers.put(NOOP_MODIFIER_NAME, t -> t);

        modifiers.put("camel", t -> {
            return toTitleCase(t, true);
        });

        modifiers.put("digify", t -> {
            return digify(t);
        });

        modifiers.put("upper", t -> {
            if (t == null) {
                return null;
            } else {
                return t.toString().toUpperCase();
            }
        });

        modifiers.put("lower", t -> {
            if (t == null) {
                return null;
            } else {
                return t.toString().toLowerCase();
            }
        });

        macros.put("web-url",
                "{http https}://{yahoo google outlook facebook linkedin yelp}.{com org gov tv}/<last-name:lower>/<first-name:lower>(.<web-page-extension>)[0.5]");
        macros.put("image-url",
                "{http https}://{yahoo google outlook facebook linkedin yelp}.{com org gov tv}/images/<alpha><alpha-numeric>[2-10].{jpg jpeg img tiff png gif}");
        macros.put("phone-number", "{1-}[0.5]\\({1 2 3 4 5 6 7 8 9}<digit>[2]\\)<digit>[3]-<digit>[4]");
        macros.put("email", "<first-name>.<last-name>@{outlook gmail yahoo yelp linkedin}.com");
    }

    private CompiledTemplate compiled;

    public RandomStringFormatGenerator(String pattern, String format) {
        this.pattern = pattern;
        this.format = format;
        StringTemplateCompiler compiler = new StringTemplateCompiler();
        compiler.setGeneratorProvider(this);
        compiler.setMacroProvider(this);
        compiler.setSetProvider(this);
        compiler.setModifierProvider(this);
        try {
            compiled = compiler.compile(format);
        } catch (IOException ex) {
            throw new IllegalArgumentException("Invalid format: " + ex.getMessage(), ex);
        }
    }

    /**
     * Add a package name prefix if the name is not absolute Remove leading "/" if
     * name is absolute
     */
    private String resolveName(String name) {
        if (name == null) {
            return name;
        }
        if (!name.startsWith("/")) {
            Class<?> c = getClass();
            while (c.isArray()) {
                c = c.getComponentType();
            }
            String baseName = c.getName();
            int index = baseName.lastIndexOf('.');
            if (index != -1) {
                name = baseName.substring(0, index).replace('.', '/') + "/" + name;
            }
        } else {
            name = name.substring(1);
        }
        return name;
    }

    /**
     * Read a resource as a stream
     */
    private InputStream getResourceAsStream(String name) {
        String resolvedName = resolveName(name);
        ClassLoader loader = RandomStringFormatGenerator.class.getClassLoader();
        return loader.getResourceAsStream(resolvedName);
    }

    /**
     * load a set from a json resource file note that the json file MUST BE in the
     * form of a json array of strings
     */
    public String[] resolveSet(String setName) {

        String[] set = sets.get(setName);
        if (set != null) {
            return set;
        }

        InputStream inputStream = getResourceAsStream("sets/" + setName + ".json");
        if (inputStream == null) {
            throw new IllegalArgumentException("Set \"" + setName + "\" was not found");
        }
        try {
            JsonNode root = mapper.readTree(inputStream);
            if (root.isArray()) {
                List<String> values = new ArrayList<>();
                for (JsonNode node : root) {
                    values.add(node.asText());
                }
                return values.toArray(String[]::new);
            } else {
                throw new IllegalArgumentException("Set \"" + setName + "\" was not a json array of strings");
            }
        } catch (IOException ex) {
            throw new IllegalArgumentException("Error loading set \"" + setName + "\": " + ex.getMessage());
        } finally {
            if (inputStream != null) {
                try {
                    inputStream.close();
                } catch (IOException ex) {

                }
            }
        }
    }

    private static String digify(Object value) {

        if (value == null) {
            return null;
        }
        String text = value.toString();

        StringBuilder converted = new StringBuilder();
        for (char ch : text.toCharArray()) {
            Character mapped = DIGIFY_MAP.get(Character.toLowerCase(ch));
            if (mapped == null) {
                converted.append(ch);
            } else {
                converted.append(mapped);
            }
        }

        return converted.toString();

    }

    /**
     * converts a string to title or camel case
     * 
     * @param text
     * @param camel if true return camel case, if false returns title case
     * @return
     */
    private static String toTitleCase(Object value, boolean camel) {
        if (value == null) {
            return null;
        }
        String text = value.toString();

        StringBuilder converted = new StringBuilder();

        boolean convertNext = true;
        for (char ch : text.toCharArray()) {
            if (Character.isSpaceChar(ch)) {
                convertNext = true;
                if (camel) {
                    continue;
                }
            } else if (Character.isAlphabetic(ch)) {
                if (convertNext) {
                    ch = Character.toTitleCase(ch);
                    convertNext = false;
                } else {
                    ch = Character.toLowerCase(ch);
                }
            } else if (camel) {
                continue;
            }
            converted.append(ch);
        }

        return converted.toString();
    }

    @Override
    public String getPattern() {
        return pattern;
    }

    @Override
    public String apply(Class<String> type, String name) throws Exception {
        Object value = compiled.generate();
        return value == null ? null : value.toString();
    }

    public String apply() throws Exception {
        return apply(String.class, "");
    }

    @Override
    public String toString() {
        return "Random format \"" + format + "\" for property name pattern \"" + this.pattern + "\"";
    }

    private class TypeGeneratorGenerator implements Generator {
        private TypeGenerator<?> typeGenerator;

        public TypeGeneratorGenerator(TypeGenerator<?> typeGenerator) {
            this.typeGenerator = typeGenerator;
        }

        @SuppressWarnings("unchecked")
        private <T> Object apply(TypeGenerator<T> generator) {
            try {
                return generator.apply((Class<T>) Object.class, "");
            } catch (Exception ex) {
                return null;
            }
        }

        @Override
        public Object generate() {
            return apply(typeGenerator);
        }
    }

    @Override
    public Generator resolveGenerator(String generatorName) {
        TypeGenerator<?> typeGenerator = typeGenerators.get(generatorName);
        if (typeGenerator == null) {
            return null;
        } else {
            return new TypeGeneratorGenerator(typeGenerator);
        }
    }

    @Override
    public String resolveMacro(String macroName) {
        return macros.get(macroName);
    }

    @Override
    public Modifier resolveModifier(String modifierName) {
        return modifiers.get(modifierName);
    }

}
