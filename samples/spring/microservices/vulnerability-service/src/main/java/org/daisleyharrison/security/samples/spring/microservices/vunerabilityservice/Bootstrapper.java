package org.daisleyharrison.security.samples.spring.microservices.vunerabilityservice;

import org.daisleyharrison.security.samples.spring.microservices.vunerabilityservice.datafeeds.NistCveDataFeed;
import org.daisleyharrison.security.samples.spring.microservices.vunerabilityservice.models.cve.Vulnerability;
import org.daisleyharrison.security.samples.spring.microservices.vunerabilityservice.models.cve.Impact;
import org.daisleyharrison.security.common.models.datastore.DatastoreCollection;
import org.daisleyharrison.security.samples.spring.microservices.shared.datafeed.DatafeedMetaData;
import org.daisleyharrison.security.samples.spring.microservices.vunerabilityservice.models.cve.BaseMetricV2;
import org.daisleyharrison.security.samples.spring.microservices.vunerabilityservice.models.cve.BaseMetricV3;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;

@Component
public class Bootstrapper implements CommandLineRunner {
    private static final Logger LOGGER = LoggerFactory.getLogger(Bootstrapper.class);
    @Value("${vulnerability-service.cve-datafeed.path}")
    private String cveDatafeedPath;

    @Value("${vulnerability-service.cve-datafeed.insert}")
    private boolean cveDatafeedInsert;

    @Value("${vulnerability-service.cve-datafeed.update}")
    private boolean cveDatafeedUpdate;

    @Value("${vulnerability-service.cve-datafeed.skip}")
    private boolean cveDatafeedSkip;

    private final DatastoreCollection<Vulnerability> vulnerabilityCollection;

    @Autowired
    public Bootstrapper(DatastoreCollection<Vulnerability>  vulnerabilityCollection) {
        this.vulnerabilityCollection = vulnerabilityCollection;
    }

    /**
     * Load the Threats repository from the NIST CVE data feed
     * 
     * @throws IOException
     */
    private void loadVulnerabilities() throws IOException {
        Path cveDatafeedPathPath = Path.of(cveDatafeedPath);

        LOGGER.info("Loading NIST CVE data from {}", cveDatafeedPath);

        NistCveDataFeed datafeed = new NistCveDataFeed();

        DatafeedMetaData metaData = datafeed.getMetaData();
        metaData.setMaxErrorsAllowed(10000);

        try (InputStream inputStream = Files.newInputStream(cveDatafeedPathPath)) {
            datafeed.parse(inputStream, cve_item -> {

                if (metaData.getProcessed() == 0) {
                    LOGGER.info("NIST CVE data feed: type {}, version {}, format {}, date {}, count {}",
                            metaData.getFeedType(), metaData.getFeedVerison(), metaData.getFeedSchema(),
                            metaData.getFeedTimestamp(), metaData.getItems());
                }

                if (cveDatafeedSkip) {
                    LOGGER.info("Skipping NIST CVE data feed");
                    return false; // Skipping
                }

                if (cve_item == null) {
                    metaData.incrementErrors();
                    LOGGER.warn("cve_item #{} is null", metaData.getProcessed());
                    return true;
                }

                Impact impact = cve_item.getImpact();
                if (impact == null) {
                    metaData.incrementErrors();
                    LOGGER.warn("cve_item #{} impact is null", metaData.getProcessed());
                    return true;
                }
                Vulnerability vulnerability = null;
                BaseMetricV3 baseMetricV3 = impact.getBaseMetricV3();
                if (baseMetricV3 == null) {
                    BaseMetricV2 baseMetricV2 = impact.getBaseMetricV2();
                    if (baseMetricV2 == null) {
                        metaData.incrementErrors();
                        LOGGER.warn("cve_item #{} baseMetricV3 and baseMetricV3 are null", metaData.getProcessed());
                        return true;
                    } else {
                        vulnerability = baseMetricV2.getCvssV2();
                        LOGGER.warn("cve_item #{} baseMetricV2 is being used", metaData.getProcessed());
                    }
                } else {
                    vulnerability = baseMetricV3.getCvssV3();
                }

                if (vulnerability == null) {
                    metaData.incrementErrors();
                    LOGGER.warn("cve_item #{} vulnerability is null", metaData.getProcessed());
                    return true;
                }

                vulnerability.setId(cve_item.getCve().getCVE_data_meta().getId());

                String id = vulnerability.getId();
                if (id == null) {
                    metaData.incrementErrors();
                    LOGGER.warn("cve_item #{} id is null", metaData.getProcessed());
                    return true;
                }

                if (!cveDatafeedUpdate || this.vulnerabilityCollection.findById(id) == null) {
                    if (cveDatafeedInsert) {
                        this.vulnerabilityCollection.insert(vulnerability);
                        metaData.incrementInserts();
                    }
                } else if (cveDatafeedUpdate) {
                    this.vulnerabilityCollection.save(vulnerability);
                    metaData.incrementUpdates();
                } else {
                    metaData.incrementExist();
                }

                return true;
            });
        }

        LOGGER.info("loaded {} new vunerabilities, {} vunerabilities updated, {} exist, {} error, from {} total vunerabilities in feed from {}",
                metaData.getInserts(), metaData.getUpdates(), metaData.getExist(), metaData.getErrors(), metaData.getItems(), metaData.getFeedTimestamp());
    }

    @Override
    public void run(String... strings) throws Exception {

        loadVulnerabilities();

    }
}